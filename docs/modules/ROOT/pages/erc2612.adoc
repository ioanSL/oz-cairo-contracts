= ERC2612

The ERC2612 token standard defines the requirements for fungible tokens. Each unit of such a token is interchangeable 
with any other unit. The token::erc2612::extensions::ERC20Permit provides an implementation of the ERC2612, including 
EIP20 with signed approval functionality, specifically designed to work in the Cairo language for Starknet.

== Interface

The full Application Binary Interface (ABI) for the Contracts for Cairo's erc20-permit-component is represented in the 
selected text. This interface encompasses four distinct components: IERC20, IERC20Metadata, INonce, and IPermit. 
Each component plays a unique role within the overall interface.

[,cairo]
----
trait ERC2612ABI<TState> {
    // IERC20
    fn total_supply(self: @TState) -> u256;
    fn balance_of(self: @TState, account: ContractAddress) -> u256;
    fn allowance(self: @TState, owner: ContractAddress, spender: ContractAddress) -> u256;
    fn transfer(ref self: TState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TState, sender: ContractAddress, recipient: ContractAddress, amount: u256
    ) -> bool;
    fn approve(ref self: TState, spender: ContractAddress, amount: u256) -> bool;

    // IERC20Metadata
    fn name(self: @TState) -> ByteArray;
    fn symbol(self: @TState) -> ByteArray;
    fn decimals(self: @TState) -> u8;

    // INonces
    fn nonces(self: @TState, owner: ContractAddress) -> felt252;

    // IPermit
    fn permit(
        ref self: TState,
        owner: ContractAddress,
        spender: ContractAddress,
        value: u256,
        deadline: u128,
        signature: Array<felt252>
    );

    fn DOMAIN_SEPARATOR(self: @TState) -> felt252;
}

----

=== ERC2612 compatibility

This component strives to align as closely as possible with the ERC2612 standard implementation. However, a few 
distinct differences can still be observed, such as:

* All differences inherited from the ERC20 standard
* The `signature` argument is presented as an Array of Felt252, which varies from the EIP2612 standard where it is specified in Weierstrass format.

== Usage

To build an ERC2612 contract with Contracts for Cairo, a constructor function needs to be established first. Then, the 
following components must be instantiated.

* ERC20Component
* NonceComponent
* ERC20PermitComponent

Here's what it looks like:

[,cairo]
----

#[starknet::contract]
mod ERC2612 {
    use openzeppelin::token::erc20::extensions::{ERC20PermitComponent};
    use openzeppelin::token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin::utils::cryptography::nonces::NoncesComponent;
    use openzeppelin::utils::cryptography::snip12::{OffchainMessageHash, StructHash, SNIP12Metadata};
    use starknet::ContractAddress;

    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);
    component!(path: ERC20PermitComponent, storage: erc20permit, event: ERC20PermitEvent);

    #[abi(embed_v0)]
    impl ERC20PermitImpl = ERC20PermitComponent::ERC20PermitImpl<ContractState>;

    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    #[abi(embed_v0)]
    impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        nonces: NoncesComponent::Storage,
        #[substorage(v0)]
        erc20permit: ERC20PermitComponent::Storage,
        
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        NoncesEvent: NoncesComponent::Event,
        #[flat]
        ERC20PermitEvent: ERC20PermitComponent::Event,
    }

    /// Required for hash computation.
    impl SNIP12MetadataImpl of SNIP12Metadata {
        fn name() -> felt252 {
            'ERC2612'
        }
        fn version() -> felt252 {
            'v1'
        }
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress,
    ) {
        self.erc20.initializer(name, symbol);
    }
}

----

When building an ERC2612 contract with Contracts for Cairo, start by establishing a constructor function. In this function, 
it's good practice to initialize the ERC20 component, although it's not mandatory.

Understand that your contract will implement SNIP12MetadataImpl, because each contract has a unique domain. This domain, 
which becomes fixed once the contract class hash is declared on-chain, cannot be altered thereafter.
